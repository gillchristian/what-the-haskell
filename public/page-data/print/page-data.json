{"componentChunkName":"component---gatsby-theme-mdx-deck-src-templates-deck-js","path":"/print","webpackCompilationHash":"81985e87db4081f28ada","result":{"data":{"deck":{"id":"6c921911-b2da-591c-95a9-e161e262ec8b","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar theme = vsDark;\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  theme: theme,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"What the Haskell?!\"), mdx(\"p\", null, \"A short introduction to Haskell\"), mdx(\"img\", {\n    src: haskellLogo,\n    style: {\n      width: 300,\n      position: 'fixed',\n      right: '3%',\n      bottom: '10%',\n      transform: 'rotate(-10deg)'\n    }\n  }), mdx(Me, {\n    mdxType: \"Me\"\n  }), mdx(\"hr\", null), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"An advanced, purely functional programming language.\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Declarative, statically typed code.\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://haskell.org\"\n  }), \"haskell.org\"))), mdx(\"hr\", null), mdx(Multiline, {\n    Elem: \"h2\",\n    lines: [\"⚠️⚠️⚠️\", \"Haskell is\", \"VERY\", \"different\", \"⚠️⚠️⚠️\"],\n    mdxType: \"Multiline\"\n  }), mdx(\"hr\", null), mdx(\"h2\", null, \"Why Haskell? \\uD83E\\uDD14\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Haskell is very different\"), mdx(\"small\", null, mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Only learn languages that teach you something new\"), mdx(\"small\", null, \" \", mdx(\"i\", null, \"Someone I don't remember\"), \" \"))), mdx(\"img\", {\n    src: drakeYes,\n    style: {\n      width: 250,\n      position: 'fixed',\n      left: '5%',\n      top: '7%',\n      transform: 'rotate(-8deg)'\n    }\n  }), mdx(\"hr\", null), mdx(Multiline, {\n    Elem: \"p\",\n    margin: 0,\n    lines: [\"Other languages and communities\", \"are adopting typed FP ideas\"],\n    mdxType: \"Multiline\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Rust: Option/Result, immutability, ADTs (enums), etc\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://reasonml.github.io/\"\n  }), \"Reason\"), \" (or \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://rescript-lang.org/\"\n  }), \"ReScript\"), \")\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/csharp/pattern-matching\"\n  }), \"Pattern matching in C#\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://arrow-kt.io/\"\n  }), \"Arrow\"), \" ecosystem in Kotlin\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://gcanti.github.io/fp-ts/\"\n  }), \"fp-ts\"), \" ecosystem in TypScript\")), mdx(\"hr\", null), mdx(\"h2\", null, \"How is Haskell different? \\uD83E\\uDD14\"), mdx(\"hr\", null), mdx(\"h2\", null, \"First a \", mdx(\"del\", {\n    parentName: \"h2\"\n  }, \"short\"), \" tour of the syntax\"), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Functions\\\"\",\n    \"title\": \"\\\"Functions\\\"\"\n  }), \"add :: Int -> Int -> Int\\nadd = \\\\a -> \\\\b -> a + b\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"1\": true,\n    \"className\": \"language-haskell\",\n    \"metastring\": \"1 title=\\\"Functions\\\"\",\n    \"title\": \"\\\"Functions\\\"\"\n  }), \"add :: Int -> Int -> Int\\nadd = \\\\a -> \\\\b -> a + b\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"1[8:10] title=\\\"Functions\\\"\",\n    \"1[8:10]\": true,\n    \"title\": \"\\\"Functions\\\"\"\n  }), \"add :: Int -> Int -> Int\\nadd = \\\\a -> \\\\b -> a + b\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"1[15:24] title=\\\"Functions\\\"\",\n    \"1[15:24]\": true,\n    \"title\": \"\\\"Functions\\\"\"\n  }), \"add :: Int -> Int -> Int\\nadd = \\\\a -> \\\\b -> a + b\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"2\": true,\n    \"className\": \"language-haskell\",\n    \"metastring\": \"2 title=\\\"Functions\\\"\",\n    \"title\": \"\\\"Functions\\\"\"\n  }), \"add :: Int -> Int -> Int\\nadd = \\\\a -> \\\\b -> a + b\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"2[7:11] title=\\\"Functions\\\"\",\n    \"2[7:11]\": true,\n    \"title\": \"\\\"Functions\\\"\"\n  }), \"add :: Int -> Int -> Int\\nadd = \\\\a -> \\\\b -> a + b\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"2[13:23] title=\\\"Functions\\\"\",\n    \"2[13:23]\": true,\n    \"title\": \"\\\"Functions\\\"\"\n  }), \"add :: Int -> Int -> Int\\nadd = \\\\a -> \\\\b -> a + b\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Functions\\\"\",\n    \"title\": \"\\\"Functions\\\"\"\n  }), \"add :: Int -> Int -> Int\\nadd = \\\\a -> \\\\b -> a + b\\n\\nadd 1 3 -- 4\\nadd 2 8 -- 10\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"1[14:24],4,5 title=\\\"Functions\\\"\",\n    \"1[14:24],4,5\": true,\n    \"title\": \"\\\"Functions\\\"\"\n  }), \"add :: Int -> Int -> Int\\nadd = \\\\a -> \\\\b -> a + b\\n\\ninc :: Int -> Int\\ninc = add 1\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Functions\\\"\",\n    \"title\": \"\\\"Functions\\\"\"\n  }), \"add :: Int -> Int -> Int\\nadd = \\\\a -> \\\\b -> a + b\\n\\ninc :: Int -> Int\\ninc = add 1\\n\\ninc 2  -- 3\\ninc 41 -- 42\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"2[7:19] title=\\\"Functions\\\"\",\n    \"2[7:19]\": true,\n    \"title\": \"\\\"Functions\\\"\"\n  }), \"add :: Int -> Int -> Int\\nadd = \\\\a b -> a + b\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Functions\\\"\",\n    \"title\": \"\\\"Functions\\\"\"\n  }), \"add :: Int -> Int -> Int\\nadd a b = a + b\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Operators\\\"\",\n    \"title\": \"\\\"Operators\\\"\"\n  }), \"add :: Int -> Int -> Int\\nadd a b = a + b\\n\\n(#) :: Int -> Int -> Int\\n(#) a b = a + b\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Operators\\\"\",\n    \"title\": \"\\\"Operators\\\"\"\n  }), \"add :: Int -> Int -> Int\\nadd a b = a + b\\n\\n(#) :: Int -> Int -> Int\\n(#) a b = a + b\\n\\n(#) :: Int -> Int -> Int\\na # b = a + b\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Operators\\\"\",\n    \"title\": \"\\\"Operators\\\"\"\n  }), \"add :: Int -> Int -> Int\\nadd a b = a + b\\n\\n(#) :: Int -> Int -> Int\\n(#) a b = a + b\\n\\n(#) :: Int -> Int -> Int\\na # b = a + b\\n\\n1 + 3 -- 4\\n8 + 9 -- 17\\n\\n1 # 3 -- 4\\n8 # 9 -- 17\\n\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Unconstrained Polymorphism\\\"\",\n    \"title\": \"\\\"Unconstrained\",\n    \"Polymorphism\\\"\": true\n  }), \"toList :: a -> [a]\\ntoList x = [x]\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"1[11:18] title=\\\"Unconstrained Polymorphism\\\"\",\n    \"1[11:18]\": true,\n    \"title\": \"\\\"Unconstrained\",\n    \"Polymorphism\\\"\": true\n  }), \"toList :: a -> [a]\\ntoList x = [x]\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Unconstrained Polymorphism\\\"\",\n    \"title\": \"\\\"Unconstrained\",\n    \"Polymorphism\\\"\": true\n  }), \"toList :: a -> [a]\\ntoList x = [x]\\n\\ntoList \\\"Catawiki\\\" -- [\\\"Catawiki\\\"]\\ntoList 42         -- [42]\\ntoList [1, 2, 3]  -- [[1, 2, 3]]\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Unconstrained Polymorphism\\\"\",\n    \"title\": \"\\\"Unconstrained\",\n    \"Polymorphism\\\"\": true\n  }), \"identity :: a -> a\\nidentity x = x\\n\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Constrained Polymorphism\\\"\",\n    \"title\": \"\\\"Constrained\",\n    \"Polymorphism\\\"\": true\n  }), \"add :: Int -> Int -> Int\\nadd a b = a + b\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Constrained Polymorphism\\\"\",\n    \"title\": \"\\\"Constrained\",\n    \"Polymorphism\\\"\": true\n  }), \"add :: Num a => a -> a -> a\\nadd a b = a + b\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"1[8:27] title=\\\"Constrained Polymorphism\\\"\",\n    \"1[8:27]\": true,\n    \"title\": \"\\\"Constrained\",\n    \"Polymorphism\\\"\": true\n  }), \"add :: Num a => a -> a -> a\\nadd a b = a + b\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"1,3[3:5],4[3:5],5[3:5],6[3:8],7[3:5],8[3:8],9[3:13],12[10:17],13[10:20],14[10:16],15[10:18],16[10:19]\",\n    \"1,3[3:5],4[3:5],5[3:5],6[3:8],7[3:5],8[3:8],9[3:13],12[10:17],13[10:20],14[10:16],15[10:18],16[10:19]\": true\n  }), \"GHCi> :i Num\\nclass Num a where\\n  (+) :: a -> a -> a\\n  (-) :: a -> a -> a\\n  (*) :: a -> a -> a\\n  negate :: a -> a\\n  abs :: a -> a\\n  signum :: a -> a\\n  fromInteger :: Integer -> a\\n  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}\\n        -- Defined in \\u2018GHC.Num\\u2019\\ninstance Num Word -- Defined in \\u2018GHC.Num\\u2019\\ninstance Num Integer -- Defined in \\u2018GHC.Num\\u2019\\ninstance Num Int -- Defined in \\u2018GHC.Num\\u2019\\ninstance Num Float -- Defined in \\u2018GHC.Float\\u2019\\ninstance Num Double -- Defined in \\u2018GHC.Float\\u2019\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Constrained Polymorphism\\\"\",\n    \"title\": \"\\\"Constrained\",\n    \"Polymorphism\\\"\": true\n  }), \"add :: Num a => a -> a -> a\\nadd a b = a + b\\n\\nadd 3 1     -- 4\\nadd 1.3 2.2 -- 3.5\\n\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"1\": true,\n    \"className\": \"language-haskell\",\n    \"metastring\": \"1 title=\\\"Constrained Polymorphism\\\"\",\n    \"title\": \"\\\"Constrained\",\n    \"Polymorphism\\\"\": true\n  }), \"average :: (Real a, Fractional b) => [a] -> b\\naverage as =\\n  let total = realToFrac (sum as)\\n      count = realToFrac (length as)\\n   in total / count\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"let expressions\\\"\",\n    \"title\": \"\\\"let\",\n    \"expressions\\\"\": true\n  }), \"average :: (Real a, Fractional b) => [a] -> b\\naverage as =\\n  let total = realToFrac (sum as)\\n      count = realToFrac (length as)\\n   in total / count\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"3:5 title=\\\"let expressions\\\"\",\n    \"3:5\": true,\n    \"title\": \"\\\"let\",\n    \"expressions\\\"\": true\n  }), \"average :: (Real a, Fractional b) => [a] -> b\\naverage as =\\n  let total = realToFrac (sum as)\\n      count = realToFrac (length as)\\n   in total / count\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"3[3:33],4[7:36] title=\\\"let expressions\\\"\",\n    \"3[3:33],4[7:36]\": true,\n    \"title\": \"\\\"let\",\n    \"expressions\\\"\": true\n  }), \"average :: (Real a, Fractional b) => [a] -> b\\naverage as =\\n  let total = realToFrac (sum as)\\n      count = realToFrac (length as)\\n   in total / count\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"5\": true,\n    \"className\": \"language-haskell\",\n    \"metastring\": \"5 title=\\\"let expressions\\\"\",\n    \"title\": \"\\\"let\",\n    \"expressions\\\"\": true\n  }), \"average :: (Real a, Fractional b) => [a] -> b\\naverage as =\\n  let total = realToFrac (sum as)\\n      count = realToFrac (length as)\\n   in total / count\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"let expressions\\\"\",\n    \"title\": \"\\\"let\",\n    \"expressions\\\"\": true\n  }), \"average :: (Real a, Fractional b) => [a] -> b\\naverage as =\\n  let total = realToFrac (sum as)\\n      count = realToFrac (length as)\\n   in total / count\\n\\naverage [1, 2, 3]       -- 2.0\\naverage [1.5, 2.5, 3.5] -- 2.5\\n\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Type synonyms\\\"\",\n    \"title\": \"\\\"Type\",\n    \"synonyms\\\"\": true\n  }), \"type ID = String\\n\\ntype Age = Int\\n\\ntype FilePath = String\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Type declarations\\\"\",\n    \"title\": \"\\\"Type\",\n    \"declarations\\\"\": true\n  }), \"data Company = Catawiki\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Type declarations\\\"\",\n    \"title\": \"\\\"Type\",\n    \"declarations\\\"\": true\n  }), \"data Company = Catawiki\\n\\ncompanyName :: Company -> String\\ncompanyName company = \\\"Catawiki\\\"\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Type declarations\\\"\",\n    \"title\": \"\\\"Type\",\n    \"declarations\\\"\": true\n  }), \"data Company = Catawiki\\n\\ncompanyName :: Company -> String\\ncompanyName company = \\\"Catawiki\\\"\\n\\ncompanyName Catawiki -- \\\"Catawiki\\\"\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Type declarations\\\"\",\n    \"title\": \"\\\"Type\",\n    \"declarations\\\"\": true\n  }), \"data Bool = True | False\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Type declarations\\\"\",\n    \"title\": \"\\\"Type\",\n    \"declarations\\\"\": true\n  }), \"data Season =\\n  Spring | Summer | Autumn | Winter\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Pattern matching\\\"\",\n    \"title\": \"\\\"Pattern\",\n    \"matching\\\"\": true\n  }), \"data Season =\\n  Spring | Summer | Autumn | Winter\\n\\nseasonName :: Season -> String\\nseasonName season =\\n  case season of\\n    Spring -> \\\"spring\\\"\\n    Summer -> \\\"summer\\\"\\n    Autumn -> \\\"autumn\\\"\\n    Winter -> \\\"winter\\\"\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Pattern matching\\\"\",\n    \"title\": \"\\\"Pattern\",\n    \"matching\\\"\": true\n  }), \"isOneOrTwo :: Int -> Bool\\nisOneOrTwo x =\\n  case x of\\n    1 -> True\\n    2 -> True\\n    y -> False\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Pattern matching\\\"\",\n    \"title\": \"\\\"Pattern\",\n    \"matching\\\"\": true\n  }), \"seasonFromString :: String -> Season\\nseasonFromString season =\\n  case season of\\n    \\\"spring\\\" -> Spring\\n    \\\"summer\\\" -> Summer\\n    \\\"autumn\\\" -> Autumn\\n    \\\"winter\\\" -> Winter\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Pattern matching\\\"\",\n    \"title\": \"\\\"Pattern\",\n    \"matching\\\"\": true\n  }), \"seasonFromString :: String -> Season\\nseasonFromString season =\\n  case season of\\n    \\\"spring\\\" -> Spring\\n    \\\"summer\\\" -> Summer\\n    \\\"autumn\\\" -> Autumn\\n    \\\"winter\\\" -> Winter\\n    other    -> ???\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Algebraic Data Types\\\"\",\n    \"title\": \"\\\"Algebraic\",\n    \"Data\": true,\n    \"Types\\\"\": true\n  }), \"data Maybe a = Nothing | Just a\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"1[6:12] title=\\\"Algebraic Data Types\\\"\",\n    \"1[6:12]\": true,\n    \"title\": \"\\\"Algebraic\",\n    \"Data\": true,\n    \"Types\\\"\": true\n  }), \"data Maybe a = Nothing | Just a\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"1[16:31] title=\\\"Algebraic Data Types\\\"\",\n    \"1[16:31]\": true,\n    \"title\": \"\\\"Algebraic\",\n    \"Data\": true,\n    \"Types\\\"\": true\n  }), \"data Maybe a = Nothing | Just a\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"Algebraic Data Types\\\"\",\n    \"title\": \"\\\"Algebraic\",\n    \"Data\": true,\n    \"Types\\\"\": true\n  }), \"data Maybe a = Nothing | Just a\\n\\nseasonFromString :: String -> Maybe Season\\nseasonFromString season =\\n  case season of\\n    \\\"spring\\\" -> Just Spring\\n    \\\"summer\\\" -> Just Summer\\n    \\\"autumn\\\" -> Just Autumn\\n    \\\"winter\\\" -> Just Winter\\n    other    -> Nothing\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"3[31:42] title=\\\"Algebraic Data Types\\\"\",\n    \"3[31:42]\": true,\n    \"title\": \"\\\"Algebraic\",\n    \"Data\": true,\n    \"Types\\\"\": true\n  }), \"data Maybe a = Nothing | Just a\\n\\nseasonFromString :: String -> Maybe Season\\nseasonFromString season =\\n  case season of\\n    \\\"spring\\\" -> Just Spring\\n    \\\"summer\\\" -> Just Summer\\n    \\\"autumn\\\" -> Just Autumn\\n    \\\"winter\\\" -> Just Winter\\n    other    -> Nothing\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"6:10 title=\\\"Algebraic Data Types\\\"\",\n    \"6:10\": true,\n    \"title\": \"\\\"Algebraic\",\n    \"Data\": true,\n    \"Types\\\"\": true\n  }), \"data Maybe a = Nothing | Just a\\n\\nseasonFromString :: String -> Maybe Season\\nseasonFromString season =\\n  case season of\\n    \\\"spring\\\" -> Just Spring\\n    \\\"summer\\\" -> Just Summer\\n    \\\"autumn\\\" -> Just Autumn\\n    \\\"winter\\\" -> Just Winter\\n    other    -> Nothing\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"data Maybe a = Nothing | Just a\\n\\nseasonFromString :: String -> Maybe Season\\nseasonFromString season =\\n  case season of\\n    \\\"spring\\\" -> Just Spring\\n    \\\"summer\\\" -> Just Summer\\n    \\\"autumn\\\" -> Just Autumn\\n    \\\"winter\\\" -> Just Winter\\n    other    -> Nothing\\n\\nseasonFromString \\\"spring\\\" -- Just Spring\\nseasonFromString \\\"summer\\\" -- Just Summer\\n\\nseasonFromString \\\"foo\\\"    -- Nothing\\nseasonFromString \\\"sumer\\\"  -- Nothing\\n\"))), mdx(\"hr\", null), mdx(\"h2\", null, \"So, how is Haskell different? \\uD83E\\uDD14\"), mdx(\"small\", null, mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Besides the syntax\"), \" \\uD83D\\uDE05\")), mdx(\"hr\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Statically typed\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type inference\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Purely functional\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Immutability\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Lazy\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Immutability \\uD83E\\uDD4A\"), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"let a = 1\\n\\na = a + 1\\n\"))), mdx(\"img\", {\n    src: drakeNo,\n    style: {\n      width: 350,\n      position: 'fixed',\n      right: '7%',\n      top: '10%',\n      transform: 'rotate(8deg)'\n    }\n  }), mdx(\"hr\", null), mdx(\"h2\", null, \"Statically Typed \\uD83E\\uDD17\"), mdx(\"img\", {\n    src: theFeels,\n    style: {\n      width: 350,\n      position: 'fixed',\n      right: '5%',\n      bottom: '7%',\n      transform: 'rotate(-8deg)'\n    }\n  }), mdx(\"hr\", null), mdx(\"h2\", null, \"Everything needs to be typed\"), mdx(\"h3\", null, \"Yeah, JSON as well!\"), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const user = {\\n  name: 'Jane',\\n  last_name: 'Doe',\\n  age: 34,\\n}\\n\\nJSON.stringify(user)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\"\n  }), \"require 'json'\\n\\nuser = {\\n  'name' => 'Jane',\\n  'last_name' => 'Doe',\\n  'age' => 34,\\n}\\n\\nuser.to_json\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"data User = User\\n  { name :: String,\\n    last_name :: String,\\n    age :: Int\\n  }\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"data User = User\\n  { name :: String,\\n    last_name :: String,\\n    age :: Int\\n  }\\n\\ninstance ToJSON User where\\n  toJSON u = object\\n    [ \\\"name\\\"      .= toJSON (name u)\\n    , \\\"last_name\\\" .= toJSON (last_name u)\\n    , \\\"age\\\"       .= toJSON (age u)\\n    ]\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"data User = User\\n  { name :: String,\\n    last_name :: String,\\n    age :: Int\\n  } deriving (Generic, ToJSON, FromJSON)\\n\\ninstance ToJSON User where\\n  toJSON u = object\\n    [ \\\"name\\\"      .= toJSON (name u)\\n    , \\\"last_name\\\" .= toJSON (last_name u)\\n    , \\\"age\\\"       .= toJSON (age u)\\n    ]\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"1:13\",\n    \"1:13\": true\n  }), \"data User = User\\n  { name :: String,\\n    last_name :: String,\\n    age :: Int\\n  } deriving (Generic, ToJSON, FromJSON)\\n\\nuser = User\\n  { name = \\\"Jane\\\",\\n    last_name = \\\"Doe\\\",\\n    age = 34\\n  }\\n\\nencode user\\n\"))), mdx(\"hr\", null), mdx(\"h3\", null, \"Type Driven Development \\uD83D\\uDEE1\\uFE0F\"), mdx(\"p\", null, \"Make impossible states impossible (to represent)\"), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"data Maybe a = Nothing | Just a\\n\\nseasonFromString :: String -> Maybe Season\\nseasonFromString season =\\n  case season of\\n    \\\"spring\\\" -> Just Spring\\n    \\\"summer\\\" -> Just Summer\\n    \\\"autumn\\\" -> Just Autumn\\n    \\\"winter\\\" -> Just Winter\\n    other    -> Nothing\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"first :: [a] -> Maybe a\\nfirst xs =\\n  case xs of\\n    []       -> Nothing\\n    (x:rest) -> Just x\\n\"))), mdx(\"hr\", null), mdx(\"h2\", null, \"Type inference \\uD83D\\uDD75\\uFE0F\\u200D\\u2640\\uFE0F\"), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"average :: (Real a, Fractional b) => [a] -> b\\naverage as =\\n  let total = realToFrac (sum as)\\n      count = realToFrac (length as)\\n   in total / count\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"average as =\\n  let total = realToFrac (sum as)\\n      count = realToFrac (length as)\\n   in total / count\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"GHCi> :t average\\naverage ::\\n  (Fractional a1, Real a2, Foldable t) => t a2 -> a1\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"(Real a2, Fractional a1, Foldable t) => t a2  -> a1\\n-- vs\\n(Real a,  Fractional b             ) => [ a ] -> b\\n\"))), mdx(\"hr\", null), mdx(\"h3\", null, \"\\uD83D\\uDC40 Example: Type inference errors \\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Lazy evaluation \\uD83D\\uDE34\"), mdx(\"hr\", null), mdx(\"h3\", null, \"\\uD83D\\uDC40 Example: Infinite lists \\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\"), mdx(\"hr\", null), mdx(\"h3\", null, \"\\uD83D\\uDC40 Example: if/else function \\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Purely functional \\uD83D\\uDE0E\"), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"key = \\\"super-secret-key\\\"\\n\\nchecksum :: ByteString -> ByteString\\nchecksum content = MD5.hash (key <> content)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"1:4\",\n    \"1:4\": true\n  }), \"checksum :: ByteString -> ByteString\\nchecksum content = \\n  let key = readFile \\\"~/.secrets\\\"\\n   in MD5.hash (key <> content)\\n\"))), mdx(\"hr\", null), mdx(\"small\", null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"\\u2022 Couldn't match type \\u2018ByteString\\u2019 with \\u2018IO ByteString\\u2019\\n  Expected type: IO ByteString\\n    Actual type: ByteString\\n\"))), mdx(\"hr\", null), mdx(\"h3\", null, \"No side effects !!! \\uD83D\\uDE20\"), mdx(\"img\", {\n    src: drakeNo,\n    style: {\n      width: 350,\n      position: 'fixed',\n      right: '7%',\n      top: '10%',\n      transform: 'rotate(8deg)'\n    }\n  }), mdx(\"hr\", null), mdx(\"h3\", null, \"No explicit side effects !!! \\uD83D\\uDE0E\"), mdx(\"img\", {\n    src: drakeYes,\n    style: {\n      width: 350,\n      position: 'fixed',\n      left: '5%',\n      top: '7%',\n      transform: 'rotate(-8deg)'\n    }\n  }), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"1[27:39] title=\\\"IO is for side effects\\\"\",\n    \"1[27:39]\": true,\n    \"title\": \"\\\"IO\",\n    \"is\": true,\n    \"for\": true,\n    \"side\": true,\n    \"effects\\\"\": true\n  }), \"checksum :: ByteString -> IO ByteString\\nchecksum content = do\\n  key <- readFile \\\"~/.secrets\\\"\\n  pure (MD5.hash (key <> content))\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"title=\\\"IO is for side effects\\\"\",\n    \"title\": \"\\\"IO\",\n    \"is\": true,\n    \"for\": true,\n    \"side\": true,\n    \"effects\\\"\": true\n  }), \"checksum :: ByteString -> IO ByteString\\nchecksum content = do\\n  key <- readFile \\\"~/.secrets\\\"\\n  pure (MD5.hash (key <> content))\\n\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"GHCi> :t readFile\\nreadFile :: FilePath -> IO String\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"GHCi> :t getLine\\ngetLine :: IO String\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"GHCi> :t putStrLn\\nputStrLn :: String -> IO ()\\n\"))), mdx(\"hr\", null), mdx(\"p\", null, \"How's \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IO String\"), \" different from \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"String\"), \" ?\"), mdx(\"p\", null, \"How to get \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"String\"), \" when I have \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IO String\"), \" ?\"), mdx(\"hr\", null), mdx(\"h3\", null, \"\\uD83C\\uDF2F Monads (and friends) \\uD83C\\uDF2F\"), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"main = do\\n  putStrLn \\\"What's your name?\\\"\\n  name <- getLine\\n  putStrLn (\\\"Hello, \\\" ++ name ++ \\\"!\\\")\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\",\n    \"metastring\": \"1:5\",\n    \"1:5\": true\n  }), \"main =\\n  putStrLn \\\"What's your name?\\\"\\n    >> (getLine\\n           >>= (\\\\name ->\\n                  putStrLn (\\\"Hello, \\\" ++ name ++ \\\"!\\\")))\\n\"))), mdx(\"hr\", null), mdx(\"p\", null, \"There's more\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Applicative\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Foldable / Traversable\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Point-free syntax\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Parsers\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Currying \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Monad transformers\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Records / Lenses\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Language extensions\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Debugging\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Is it worth? \\uD83E\\uDD14\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Totally!!! \\uD83D\\uDCAF \", mdx(\"sup\", null, \"*\")), mdx(\"img\", {\n    src: worthIt\n  }), mdx(\"br\", null), mdx(\"small\", null, mdx(\"small\", null, mdx(\"small\", null, mdx(\"p\", null, \"*\", \" at least to me \\uD83E\\uDD13\")))), mdx(\"hr\", null), mdx(\"h2\", null, \"Fin \\uD83D\\uDE05\"), mdx(\"p\", null, \"See you at #functional\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Questions?\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"6c921911-b2da-591c-95a9-e161e262ec8b","slug":"","title":"What the Haskell?!"}}}